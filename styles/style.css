/* ! Se utilizará este tipo de comentario para mostrar IMPORTANTE, PROBLEMAS, REVISION */
/* TODO - se utilizará este tipo de comentario para mostrar instrucciones/requerimientos (to do list) */
/* ? Con este marcaremos dudas especificas */
/* comentario normal (notas-información) */

/* standard settings */
* {
  margin: 0;
  padding: 0;
}

/* COLOR CODE: 
#fecc01 YELLOW MUSTARD
#232323 TEXT
#f1f1f1 BACKGROUNDS - GALLERY SLIDES - SECTION
#e2e2e2 CARDS BACKGROUND
#fecc01 BTN 
#ffffff WHITE*/

h1,
h2,
h3,
h4,
h5,
h6 {
  font-family: "Playfair Display", serif;
  font-weight: bold;
  font-size: 30px;
}

p,
a,
form,
li {
  font-family: "Lato", sans-serif;
  font-size: 17px
}

body {
  background-color: rgb(38, 37, 37);
}

.hero {
  height: 100vh;
  display: flex;
  /* En este caso lo uso flex para poder tener los hijos uno al lado del otro (la foto y la info). Los necesitamos asi para este diseño. */
  margin: 30px;
}

.photo-1 img {
  height: 100vh;
  border-top-left-radius: 250px;
  /* Si la img fuese mas ancha, quizas habria que darle un width:auto. En este caso la imagen tiene un ancho mas angosto, por eso al darle el height 200vh se ve bien, sin necesidad de darle un valor a esa propiedad. */
  box-shadow: -13px -12px 36px 4px rgba(252, 248, 170, 0.39);
}

.hero-info {
  background-color: rgb(255, 255, 255);
  border-top-right-radius: 30px;
  height: 100vh;
  overflow: hidden;
  /* Esta propiedad con valor "hidden", hace que, en este caso, el borde superior se aplique bien. Si un elemento se sobresale o desborda, esta propiedad lo recorta, lo deja de hacer visible. En este caso, logramos que el fondo amarillo de "hero-info-1" deja de sobresalir arriba y hace visible el borde aplicado al contenedor, no lo sobresale más. Pasó lo mismo con el caso del hero-info-2, se le sumo el padding top y quedo mas grande que los 100vh de la section HERO, entonces me lo recorto*/
}

.hero-info-1 {
  /* 
  padding-left: 30px;
  padding-top: 60px;
  padding-bottom: 200px; */
  height: 50vh;
  background-color: #fecc01;
  display: flex;
  flex-direction: column;
  justify-content: center;
  /* align-items: flex-start; */
  /* Con estos cambios, hago que el contenido de este div se pueda organizar facilmente. Usamos FLEX para poder moverlo, cambiar su comportamiento y acomodarlo. Con height le dimos una altura directamente de la mitad de pantalla, porque sabemos que el hero tiene 100vh y queremos que los dos div (hero-info-1 y hero-info-2)ocupen el espacio de hero-info.  */
  padding-left: 30px;
  box-shadow: -19px -25px 30px 6px rgba(38, 37, 37, 1) inset;
  /* TIP: rgba comparado con rgb, lo que hace es agregar un valor extra "alpha -esa a del final, la cual controla la transparencia (opacidad) del color-"  */
}

.hero-info-1 h1 {
  font-size: 45px;
}

.hero-info-1 p {
  font-size: 25px;
  color: rgb(43, 42, 42);
}

.hero-info-2 {
  /* background-color: #e5e3e3; */
  height: 100vh;
  background-color: rgb(38, 37, 37);
  color: white;
  padding-left: 30px;
}

.hero-info-2 p {
  margin-right: 170px;
  /* PRIMERO: Con esta seleccion lo que hice fue modificar exclusivamente la etiqueta p que se encuentra en el div contenedor de hero-info-2. Con este marging lo que cambie es el comportamiento por defecto de la etiqueta p, que es ocupar todo el espacio a lo ancho en formato de bloque. Les dije que de su lado derecho, quiero que se acorten y tengan un margen externo de 190px para con respecto el borde del div. Asi logre que el texto quede mas estetico y compacto a mi gusto.*/
}

.countries {
  font-weight: bold;
  font-size: 20px;
  /* Para comenzar a la misma altura que el texto en el hero-info-1 */
  padding-top: 20px;
  padding-bottom: 15px;
}

/* .hero-info-2.hijo {
  font-size: 1000px;
} */
/* ESTO SOLO FUNCIONARIA si yo tengo una etqiueta en html con esas dos clases al mismo tiempo dentro de la misma. (class 1: .hero-info class 2: .hijo) */

.last-p-hero {
  font-weight: bold;
  font-size: 25px;
  margin-top: 7px;
}

.cta {
  padding: 12px 97px;
  /* el orden de valor de padding es: primer valor: arriba y abajo - segundo valor: 2 costados. Si escribiesemos 4 valores distintos, entonces se aplican en sentido horario, desde arriba hacia la derecha.Si uso un solo valor de padding, se aplicará el mismo a los 4 lados.-*/
  margin-top: 20px;
  font-size: 20px;
  cursor: pointer;
  background-color: #fecc01;
  border: none;
  border-radius: 10px;
  transition: .1s;
  position: relative;
  /* Le doy position relative al boton para que en este caso las lineas que formaran los span estilados vayan hacia el borde del boton y no aparezcan en cualquier parte del html */
  overflow: hidden;
  /* Esta propiedad controla QUÉ PASA CON EL CONTENIDO QUE SE SALE del tamaño del contenedor. Nosotros en este caso hicimos que los span salgan del tamaño del contenedor con el estilo que le dimos a cada uno mas abajo (linea 150, 169, 177, 189). 
  HIDDEN esta ocultando todo esto que se sale, Y CUANDO COMIENZA A ESTAR en el mismo lugar que su contenedor, ahi ya es visible, por eso el movimiento?*/
}

button:hover {
  font-weight: bold;
  transform: scale(1.1);
}

button span {
  position: absolute;
  background-color: white;
  /* Con position absolute lo que hago es poder colocar los span exactamente donde yo quiera respecto al boton: arriba, abajo, izquierda, derecha.*/
  transition: 0.5s;
}

button span:nth-child(1) {
  width: 100%;
  height: 4px;
  top: 0;
  left: -100%
    /* Con la propiedad: nth-child(1):
  Le dije a CSS que en el html tome el primer hijo del boton como el span numero 1 para configurar.
  Con Width le dije que esta linea de borde que estoy armando (para animar) sea del mismo ancho que el box del boton.
  Con height le dije la altura que tendra la linea (grosor).
  Con Top le dije que la linea debe estar pegada al box del boton.
  Con Left en negativo le dije que debe estar posicionado del lado/costado izquierdo pero por fuera del box del boton. Recordar que span es un elemento en linea, por eso se mantiene asi como border.
  ESTA CONFIGURACION SE REPETIRA PARA CADA SPAN, ASIGNANDOLE EL NUMERO POR ORDEN DE POSICION EN EL HTML DENTRO DE BUTTON. 
  
TENER EN CUENTA QUE SI TENGO OTRA ETIQUETA/ELEMENTO ANTES QUE LOS SPAN (ej svg, img, p...) ENTONCES SE ME ROMPE EL ORDEN Y LA LOGICA. 
Debo cambiar el valor de css y utilizar: 
:nth-of-type(n) 
porque de esta forma estamos ignorando los otros elementos ya que solo cuenta los elementos del mismo tipo (que es span porque esta en esa seleccion).*/
}

button span:nth-child(2) {
  width: 100%;
  height: 4px;
  bottom: 0;
  right: -100%
    /* Aqui se creo el borde de abajo para animar. el ancho y alto siguen siendo el mismo, pero le cambio la posicion a bottom para que este debajo y a su vez con right en negativo lo pongo en ese costado pero por fuera del box del boton. */
}

button span:nth-child(3) {
  width: 4px;
  height: 100%;
  bottom: -100%;
  left: 0
    /* Aqui estamos cambiando el sentido de este borde creado con span para animar. En los dos span anteriores creamos un borde horizontal, ahora le estamos diciendo que sera vertical y comenzara desde abajo. Lo hacemos asi para que con el hover luego se simule que sube hasta arriba siguiendo el borde del boton.
   Con width le digo que tiene ese ancho, ese grosor (finito en este caso).
   Con height le estoy dando toda la altura que tendra, que es del 100% del tamaño del boton.Esto hace que el span se estire verticalmente en linea.
   Con bottom le digo que comience completamente por debajo del boton, que no este a su misma altura. Verticalmente hablando.
   Con left le digo que se pegue completamente al lado izquierdo del boton.  */
}

button span:nth-child(4) {
  width: 4px;
  height: 100%;
  top: -100%;
  right: 0
    /* Mismo caso que el de arriba, solo que cambiamos:
  Con top le digo que comience bien arriba, fuera del boton.
  Con right le dije que se pegue completamente al lado derecho del boton.   */
}

button:hover span:nth-child(1) {
  left: 0;
}

button:hover span:nth-child(2) {
  right: 0;
}

button:hover span:nth-child(3) {
  bottom: 0;
}

button:hover span:nth-child(4) {
  top: 0;
  /* Aqui debemos entender que le hemos aplicado un hover al boton teniendo en cuenta que al pasar el mouse se le debe dar una propiedad especifica a cada uno de los span. Tenemos que volver a nombrar cada span junto al hover. Y ES MUY IMPORTANTE, que la propiedad y valor que se cambia es la que pusimos como negativa en su estilo de origen. Ponemos lo contrario, lo llevamos a 0, para que de esta forma se posicione exactamente en el borde del boton Y GENERE EL MARCO QUE QUEREMOS CON EL HOVER. TENER EN CUENTA QUE PARA QUE ESTO FUNCIONE, tambien hay que agregar un transition en el llamado de span (ver linea 141 del codigo). */
}



/* object-fit: contain; */
/* Esta propiedad ajusta una img dentro de su contenedor. El valor contain hace que la img escale hasta tener el mismo tamańo de su contenedor, que en esta seccion es 100% */